---
import HeadingWithIcon from './reusables/HeadingWithIcon.astro';
import Alert from './reusables/Alert.astro';
import { calculateAverageNumber, calculatePercentageOf } from '@scripts/utils.ts';

const isProduction = import.meta.env.PRODUCTION_BUILD;

export const isDrop = (previous: number[], current: number) => {
  const previousAverage = calculateAverageNumber(previous);
  return calculatePercentageOf(current, previousAverage, true) < 90;
};

const formatNumber = (num: number): string => {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1) + 'M';
  } else if (num >= 1000) {
    return (num / 1000).toFixed(1) + 'k';
  }
  return num.toString();
};

const CLOUDFLARE_GRAPHQL_URL = 'https://api.cloudflare.com/client/v4/graphql';
const ZONE_ID = import.meta.env.CF_ZONE_ID;
const API_TOKEN = import.meta.env.CF_RADAR_TOKEN;

const generateMockData = () => {
  const dailyData = [];
  const currentDate = new Date();

  for (let i = 29; i >= 0; i--) {
    const date = new Date();
    date.setDate(currentDate.getDate() - i - 1);
    const formattedDate = date.toISOString().split('T')[0];

    dailyData.push({
      date: formattedDate,
      pageViews: Math.floor(Math.random() * 3000) + 1000,
      requests: Math.floor(Math.random() * 5000) + 2000,
      uniques: Math.floor(Math.random() * 2000) + 500,
    });
  }

  const totalUniques = dailyData.reduce((sum, day) => sum + day.uniques, 0);
  const totalRequests = dailyData.reduce((sum, day) => sum + day.requests, 0);
  const totalBytes = Math.floor(Math.random() * 10000000000) + 5000000000;

  return { dailyData, totalUniques, totalRequests, totalBytes };
};

const fetchCloudflareStats = async () => {
  const currentDate = new Date();
  const thirtyDaysAgo = new Date();
  // Using 31 days because I don't want current day
  thirtyDaysAgo.setDate(currentDate.getDate() - 31);

  // const formattedCurrentDate = currentDate.toISOString().split('T')[0];
  const formattedThirtyDaysAgo = thirtyDaysAgo.toISOString().split('T')[0];

  const headers = {
    'Content-Type': 'application/json',
    Authorization: `Bearer ${API_TOKEN}`,
  };

  // https://pages.johnspurlock.com/graphql-schema-docs/cloudflare.html#AccountHttpRequests1dGroupsSum
  const dailyResponse = await fetch(CLOUDFLARE_GRAPHQL_URL, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify({
      query: `
          query GetDailyStats($zoneId: String!, $since: ISO8601DateTime!) {
            viewer {
              zones(filter: { zoneTag: $zoneId }) {
                totals: httpRequests1dGroups(
                  filter: { date_gt: $since },
                  limit: 30
                ) {
                  uniq { uniques }
                  sum { requests bytes }
                }
                httpRequests1dGroups(
                  filter: { date_gt: $since },
                  limit: 30,
                  orderBy: [date_ASC]
                ) {
                  dimensions { date }
                  uniq { uniques }
                  sum { pageViews requests }
                }
              }
            }
          }
        `,
      variables: {
        zoneId: ZONE_ID,
        since: formattedThirtyDaysAgo,
      },
    }),
  });

  if (!dailyResponse.ok) {
    throw new Error(`HTTP error! Daily: ${dailyResponse.status}`);
  }

  const data = await dailyResponse.json();

  try {
    const zoneData = data.data.viewer.zones[0];
    const totalUniques = zoneData.totals[0]?.uniq?.uniques || 0;
    const totalRequests = zoneData.totals[0]?.sum?.requests || 0;
    const totalBytes = zoneData.totals[0]?.sum?.bytes || 0;
    const dailyData = zoneData.httpRequests1dGroups.map((day: any) => {
      return {
        date: day.dimensions.date,
        pageViews: day.sum.pageViews,
        requests: day.sum.requests,
        uniques: day.uniq.uniques,
      };
    });

    return { dailyData, totalUniques, totalRequests, totalBytes };
  } catch (error) {
    console.log(`Can't fetch Cloudflare stats: ${error}`);
    return { dailyData: [], totalUniques: 0, totalRequests: 0, totalBytes: 0 };
  }
};

const {
  dailyData: data30Days,
  totalUniques,
  totalRequests,
  totalBytes,
} = isProduction ? await fetchCloudflareStats() : generateMockData();

const totalBandwidthGB = (totalBytes / (1024 * 1024 * 1024)).toFixed(2);

const highestVisitorsCount = data30Days.reduce((maxObj: any, currentObj: any) => {
  return currentObj.uniques > maxObj.uniques ? currentObj : maxObj;
});
---

<div class='border rounded-2xl w-full p-4 select-none my-8'>
  <div class='flex flex-col md:flex-row md:justify-between md:items-start gap-4'>
    <HeadingWithIcon icon='icon-park-outline:analysis' title="Cloudflare's Monthly Statistics" level={2} />

    <div class='hidden md:flex gap-6 md:gap-8'>
      <div class='text-center'>
        <h2 class='font-bold mb-0 text-success'>{formatNumber(totalUniques)}</h2>
        <small class='text-base-content/90'>Unique visitors</small>
      </div>
      <div class='text-center'>
        <h2 class='font-bold mb-0 text-success'>{formatNumber(totalRequests)}</h2>
        <small class='text-base-content/90'>Total requests</small>
      </div>
    </div>
  </div>

  {
    !isProduction && (
      <Alert type='warning'>
        Real stats are generated only on <a href='https://dav.one/about-website/'>main branch</a>
      </Alert>
    )
  }

  <div id='chart-container' class='hidden md:flex w-full h-24 gap-1 mb-1 mt-8 items-end'>
    {
      data30Days.map((day: any, index: number) => {
        // Get the previous three days, ensuring we do not go out of bounds
        const previousDays = data30Days.slice(Math.max(index - 3, 0), index);

        const conditionalClasses = [
          index === 0 ? 'sm:rounded-bl-xl' : '',
          index === data30Days.length - 1 ? 'sm:rounded-br-xl' : '',
          isDrop(
            previousDays.map((d: any) => d.uniques),
            day.uniques,
          )
            ? 'bg-error'
            : 'bg-success',
        ]
          .filter(Boolean)
          .join(' ');

        return (
          <div
            class={`chart-bar ${conditionalClasses}`}
            style={`height: ${calculatePercentageOf(day.uniques, highestVisitorsCount.uniques, true)}%`}
            title={`${day.date}\n\n${day.pageViews} page views\n${day.uniques} unique visitors`}
          />
        );
      })
    }
  </div>

  <!-- Display above "md" media query -->
  <div class='hidden md:flex justify-between'>
    <small class='px-1 text-base-content/90'>{data30Days[0].date}</small>
    <small class='px-1 text-base-content/90'>{data30Days[data30Days.length - 1].date}</small>
  </div>

  <!-- Display below "md" media query -->
  <div class='md:hidden grid grid-cols-2 md:grid-cols-4 gap-4'>
    <div class='flex flex-col items-center justify-center p-4 bg-base-content/3 rounded-xl'>
      <h2 class='font-bold text-primary mb-2'>{formatNumber(totalUniques)}</h2>
      <span class='text-center'>Unique Visitors</span>
    </div>

    <div class='flex flex-col items-center justify-center p-4 bg-base-content/3 rounded-xl'>
      <h2 class='font-bold text-primary mb-2'>{formatNumber(highestVisitorsCount.uniques)}</h2>
      <span class='text-center'>Maximum Daily Visitors</span>
    </div>

    <div class='flex flex-col items-center justify-center p-4 bg-base-content/3 rounded-xl'>
      <h2 class='font-bold text-primary mb-2'>{formatNumber(totalRequests)}</h2>
      <span class='text-center'>Total Requests</span>
    </div>

    <div class='flex flex-col items-center justify-center p-4 bg-base-content/3 rounded-xl'>
      <h2 class='font-bold text-primary mb-2'>{totalBandwidthGB} GB</h2>
      <span class='text-center'>Total Bandwidth</span>
    </div>
  </div>
</div>
